import heapq

# Define a class for the A* algorithm
class AStar:
    def __init__(self, graph, start, goal, heuristic):
        self.graph = graph  # Graph represented as a dictionary of neighbors and costs
        self.start = start
        self.goal = goal
        self.heuristic = heuristic  # Heuristic function (dictionary of heuristic values)
        self.open_list = []  # Priority queue for nodes to explore
        self.closed_list = set()  # Set for nodes that have been explored
        self.g_scores = {start: 0}  # Dictionary to store g(n) values
        self.parents = {start: None}  # Dictionary to store parent nodes

    def a_star_search(self):
        # Add the starting node to the open list with its f(n) value
        heapq.heappush(self.open_list, (self.f(self.start), self.start))

        while self.open_list:
            # Pop the node with the lowest f(n) value from the open list
            current_f, current_node = heapq.heappop(self.open_list)

            # If we have reached the goal, reconstruct the path
            if current_node == self.goal:
                return self.reconstruct_path()

            # Move the node from the open list to the closed list
            self.closed_list.add(current_node)

            # Explore the neighbors of the current node
            for neighbor, cost in self.graph[current_node]:
                if neighbor in self.closed_list:
                    continue  # Skip already explored nodes

                # Calculate g(n), h(n), and f(n) for the neighbor
                tentative_g = self.g_scores[current_node] + cost
                if neighbor not in self.g_scores or tentative_g < self.g_scores[neighbor]:
                    self.g_scores[neighbor] = tentative_g
                    heapq.heappush(self.open_list, (self.f(neighbor), neighbor))
                    self.parents[neighbor] = current_node

        return None  # If no path is found

    def f(self, node):
        # f(n) = g(n) + h(n)
        return self.g_scores.get(node, float('inf')) + self.heuristic.get(node, 0)

    def reconstruct_path(self):
        # Reconstruct the path from start to goal by following the parents
        path = []
        current_node = self.goal
        while current_node is not None:
            path.append(current_node)
            current_node = self.parents[current_node]
        return path[::-1]  # Reverse the path to get from start to goal


# Example graph (adjacency list with weights)
graph = {
    'A': [('B', 1), ('C', 3)],
    'B': [('A', 1), ('D', 2), ('E', 5)],
    'C': [('A', 3), ('E', 1)],
    'D': [('B', 2), ('E', 2)],
    'E': [('B', 5), ('C', 1), ('D', 2)]
}

# Example heuristic values (h(n))
heuristic = {
    'A': 4,  # Heuristic value from A to goal (E)
    'B': 3,  # Heuristic value from B to goal (E)
    'C': 2,  # Heuristic value from C to goal (E)
    'D': 1,  # Heuristic value from D to goal (E)
    'E': 0   # Goal node has heuristic value 0
}

# Create an instance of AStar and search for the path
start_node = 'A'
goal_node = 'E'
a_star = AStar(graph, start_node, goal_node, heuristic)

# Perform A* search
path = a_star.a_star_search()
if path:
    print(f"Optimal path from {start_node} to {goal_node}: {path}")
else:
    print(f"No path found from {start_node} to {goal_node}.")
